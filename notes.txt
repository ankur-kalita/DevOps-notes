Class 1 -> Microservices Architecture

1) 3 axes of scalability ->
 x axis means horizontal scalling, its like load balancers distribute the traffic.
 y axis means vertical scalling, its like functional decomposition into microservices.
 z axis means sharding 

2) Load balancing ->
 Distribute the incoming traffic across instances to maintain avaibility and scalability.
 2 types of balancers -> 
    i) L4 load balancer -> knows only abt ip, port, tcp/udp...jst send the traffic to a
        free server, super fast
    ii) L7 load balancer -> can read the http request content and act accordingly...
        slightly slower.

3) DNS -> A registry of ip adresses for human readable domain name.

4) Service Discovery -> keep track of active service instances for dynamic routing.

5) Sync and Async communication -> f
 sync -> caller wait fr responses...fast but risky, if one goes down, chain reaction.
 async -> caller sends messages and continues...message broker in between: kafka

6) Publish-Subscribe Model & Skew Model (async messaging patterns) ->
    PSM -> Producer sends one message , many consumers can listen.
    Skew -> One message , only one consumer picks it.

7) Event Syncing -> Services publish events to an event bus (Kafka). Other services
    subscribe to events for reactive workflows.

8) API -> Single entry point to all backend microservices.

9) Externalizing Logs -> Never store logs inside containers. They die, logs die. ðŸ’€

10) 12 Factor app -> The bible for cloud native-apps.



Class 2 -> DevOps Introduction

1) What is DevOps -> DevOps basically make a bridge between software development and IT services to deliver application
and services faster and reliable. It is basically set of philosphy, tools etc...

2) SDLC lifecylce -> SDLC is a structured process to build software from idea and deliver and maintanace. Those are planning ,
analysis, design, implementation, testing and integration, maintanance. SDLC mane software development life cycle.

3) Zero Down Time Upgrade -> Deploying a new version of ur application without stopping the existing version of the application.

4) What is there in devops which is not ci-cd -> DevOps practices beyond ci-cd such as IaC, Monitoring & Logging, Version 
 control, security, Collaboration and culture, Containerization etc...ci-cd is only one part of devops.

5) Artifacts -> Final packaged output of a build that can be deployed...ex as JARs, EXE, ZIP, Docker images

6) DevSecOps -> Development + Security + Operation

7) Linting -> Static code checks for style rules, formatting, syntax errors etc...Ex as EsLint

8) Shift-Left Approach -> Testing & security done earlier in the SDLC...instead of testing after coding, shift tests to:
 requirements, design, code-review and build stage...

9) Performance testing tools -> 
 Load testing -> JMeter, LoadRunner, Gatling
 Stress testing -> Locust
 APM Monitoring -> Grafana

10) Software Composition Analysis (SCA) -> check open source dependencies for vulnarabilities and license issues.

11) Static Application Security Testing (SAST) -> Code level security scan without running the program. No runtime behaviour testing. ex as SonarQube.

12) Dynamic Application Security Testing (DAST) -> Scan running application and find runtime vulnarabilities.

13) CI/CD -> 
 CI -> Code integration and automatically build and test
 CD -> automatically deploy to environments

14) Continous delivery -> code is ready for release and does require human approval.
    Continous deployment -> code automatically goes to prod, doesnot require human approval.

15) Artifact Repository tools -> 

16) Even if using Docker Images, why Nexus/JFrog?

 * Store other artifacts too (JARs, Helm charts, packages)
 * Versioning & retention policies
 * Faster local access â†’ donâ€™t pull from internet always
 * Secure + governance + scanning
 * Works across multi-cloud environments

Docker Hub â‰  enterprise-grade governance.

17) What is SonarQube?

 A code quality and security scanning tool.
 It performs:
  * SAST
  * Code smells detection
  * Maintainability metrics
  * Bug + Vulnerability reports
  * Coverage tracking

18) High Cyclomatic Complexity ->

 Metric that shows:
 * Too many decision paths in code (if/else)
 * Hard to test & maintain
High value = bad â†’ needs refactor

19) Code Smells (SonarQube)

 Code patterns that may cause future issues:
 * Duplicate code
 * Long methods
 * Dead code
 * Bad naming