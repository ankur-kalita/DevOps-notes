Class 1 -> Microservices Architecture

1) 3 axes of scalability ->
 x axis means horizontal scalling, its like load balancers distribute the traffic.
 y axis means vertical scalling, its like functional decomposition into microservices.
 z axis means sharding 

2) Load balancing ->
 Distribute the incoming traffic across instances to maintain avaibility and scalability.
 2 types of balancers -> 
    i) L4 load balancer -> knows only abt ip, port, tcp/udp...jst send the traffic to a
        free server, super fast
    ii) L7 load balancer -> can read the http request content and act accordingly...
        slightly slower.

3) DNS -> A registry of ip adresses for human readable domain name.

4) Service Discovery -> keep track of active service instances for dynamic routing.

5) Sync and Async communication -> f
 sync -> caller wait fr responses...fast but risky, if one goes down, chain reaction.
 async -> caller sends messages and continues...message broker in between: kafka

6) Publish-Subscribe Model & Skew Model (async messaging patterns) ->
    PSM -> Producer sends one message , many consumers can listen.
    Skew -> One message , only one consumer picks it.

7) Event Syncing -> Services publish events to an event bus (Kafka). Other services
    subscribe to events for reactive workflows.

8) API -> Single entry point to all backend microservices.

9) Externalizing Logs -> Never store logs inside containers. They die, logs die. ðŸ’€

10) 12 Factor app -> The bible for cloud native-apps.



Class 2 -> DevOps Introduction

1) What is DevOps -> DevOps basically make a bridge between software development and IT services to deliver application
and services faster and reliable. It is basically set of philosphy, tools etc...

2) SDLC lifecylce -> SDLC is a structured process to build software from idea and deliver and maintanace. Those are planning ,
analysis, design, implementation, testing and integration, maintanance. SDLC mane software development life cycle.

3) Zero Down Time Upgrade -> Deploying a new version of ur application without stopping the existing version of the application.

4) What is there in devops which is not ci-cd -> DevOps practices beyond ci-cd such as IaC, Monitoring & Logging, Version 
 control, security, Collaboration and culture, Containerization etc...ci-cd is only one part of devops.

5) Artifacts -> Final packaged output of a build that can be deployed...ex as JARs, EXE, ZIP, Docker images

6) DevSecOps -> Development + Security + Operation

7) Linting -> Static code checks for style rules, formatting, syntax errors etc...Ex as EsLint

8) Shift-Left Approach -> Testing & security done earlier in the SDLC...instead of testing after coding, shift tests to:
 requirements, design, code-review and build stage...

9) Performance testing tools -> 
 Load testing -> JMeter, LoadRunner, Gatling
 Stress testing -> Locust
 APM Monitoring -> Grafana

10) Software Compliance Analysis (SCA) -> check open source dependencies for vulnarabilities and license issues.

11) Static Analysis Security Testing (SAST) -> Code level security scan without running the program. No runtime behaviour testing. ex as SonarQube.

12) Dynamic Analysis Security Testing (DAST) -> Scan running application and find runtime vulnarabilities.

13) CI/CD -> 
 CI -> Code integration and automatically build and test
 CD -> automatically deploy to environments

14) Continous delivery -> code is ready for release and does require human approval.
    Continous deployment -> code automatically goes to prod, doesnot require human approval.

15) Artifact Repository tools -> 

16) Even if using Docker Images, why Nexus/JFrog?

 * Store other artifacts too (JARs, Helm charts, packages)
 * Versioning & retention policies
 * Faster local access â†’ donâ€™t pull from internet always
 * Secure + governance + scanning
 * Works across multi-cloud environments

Docker Hub â‰  enterprise-grade governance.

17) What is SonarQube?

 A code quality and security scanning tool.
 It performs:
  * SAST
  * Code smells detection
  * Maintainability metrics
  * Bug + Vulnerability reports
  * Coverage tracking

18) High Cyclomatic Complexity ->

 Metric that shows:
 * Too many decision paths in code (if/else)
 * Hard to test & maintain
High value = bad â†’ needs refactor

19) Code Smells (SonarQube)

 Code patterns that may cause future issues:
 * Duplicate code
 * Long methods
 * Dead code
 * Bad naming
                                                                CD
20) System integration Testing (SIT) -> deploy and test(automated) -> Performance Testing -> Security Testing -> DAST -> Production Deploy

21) Mocking and testing -> automated unit test

22) Line coverage , Function coverage and Class coverage

Class 3 -> Linux basics & useful commands

1) Navigation & listing
 - pwd            -> print working directory
 - cd <dir>       -> change directory (cd ~, cd .., cd -)
 - ls             -> list files
   * ls -l        -> long listing (permissions, owner, size, mtime)
   * ls -a        -> include hidden files
   * ls -h        -> human readable sizes
   * ls -t        -> sort by time
   * ls -ltr      -> long listing, reverse by time (oldest first)

2) File & directory operations
 - mkdir <dir>           -> create directory
 - rmdir <dir>           -> remove empty directory
 - rm file               -> remove file
 - rm -r <dir>           -> recursive remove
 - rm -rf <dir>          -> force recursive remove (dangerous)
 - mv src dst            -> move/rename
 - cp src dst            -> copy (cp -r for directories)
 - touch file            -> create empty file / update timestamp

3) Viewing file contents
 - cat file
 - less / more           -> paged viewing
 - head -n 20 file
 - tail -n 50 file
 - tail -f file          -> follow logs
 - echo "text" > file    -> overwrite
 - echo "text" >> file   -> append

4) Permissions model (rwx)
 - Owner / Group / Others each have r (4), w (2), x (1).
 - Numeric examples:
   * 755 -> rwxr-xr-x  (owner rwx, group rx, others rx)
   * 644 -> rw-r--r--  (owner rw, group r, others r)
   * 471 mentioned -> interpreted as special bits + perms:
       - Leading digit (setuid/setgid/sticky): 4=setuid, 2=setgid, 1=sticky
       - 471 -> setuid + owner rwx? (rare); prefer explicit examples.
 - Symbolic examples:
   * chmod u+x file     -> add execute to user
   * chmod g-w file
   * chmod o=r file

5) Special permission bits
 - setuid (4xxx)   -> executable runs with file owner privileges
 - setgid (2xxx)   -> executable/dir inherits group
 - sticky bit (1xxx)-> on directories prevents others from deleting files they don't own (e.g., /tmp has sticky bit)

6) Change ownership & group
 - chown user file
 - chown user:group file
 - chgrp group file

7) ACLs (fine-grained permissions)
 - getfacl file
 - setfacl -m u:alice:rwx file    -> give user alice permissions
 - setfacl -x u:alice file        -> remove ACL entry
 - Useful when owner/group model is insufficient.

8) User management & switching
 - useradd <user> or adduser <user>
 - passwd <user>         -> set password
 - su - <user>           -> switch user (requires password)
 - sudo <cmd>            -> run command as root (requires sudoers)

9) Process management & inspection
 - ps aux               -> all processes (BSD style)
 - ps -ef               -> all processes (UNIX style)
 - ps -efT              -> show threads
 - ps aux | grep sleep  -> find processes (use grep -v grep or pgrep)
 - pgrep <name>         -> get PIDs by name
 - top / htop           -> interactive process viewer
 - kill <pid>, kill -9 <pid>

10) find command (powerful)
 - find /path -name "file.txt"
 - find . -type f        -> files only
 - find . -type d        -> directories only
 - find / -perm 644      -> files with exact permission
 - find . -mtime -7      -> modified within last 7 days
 - find . -size +10M     -> larger than 10MB
 - find . -exec rm {} \; -> run command per result
 - find . -print0 | xargs -0 rm   -> safe with spaces

11) locate
 - locate filename       -> very fast, uses updatedb (database)
 - updatedb              -> rebuild locate database (requires root)

12) Searching & text tools
 - grep "pattern" file
 - grep -R "pattern" dir
 - grep -n "pattern" file -> show line numbers
 - wc -l file            -> count lines
 - sed, awk              -> stream editing / processing

13) File attributes & umask
 - umask                 -> default permission mask for new files (e.g., 022 -> files 644, dirs 755)
 - stat file             -> detailed file metadata

14) Logs & best practices
 - Do not store logs inside containers (ephemeral) â€” redirect to stdout/stderr or external log store.
 - Use full paths in scripts, quote variables, avoid rm -rf mistakes.

15) Useful examples
 - Make a script executable and run:
   * chmod +x script.sh
   * ./script.sh
 - Find and delete *.tmp older than 30 days:
   * find /var/log -type f -name '*.tmp' -mtime +30 -exec rm {} \;
 - Give user alice rwx on file via ACL:
   * setfacl -m u:alice:rwx /data/file

16) Quick tips
 - Prefer sudo for administrative commands instead of logging in as root.
 - Use --dry-run or echo commands before executing destructive operations.
 - Use name-based searches with locate for speed; use find for precise, up-to-date results.

 Summary -> Practice the commands above; focus on permissions (numeric vs symbolic), find/locate, ps variants and process control, and ACLs (setfacl/getfacl).

17) Kernel -> interface b/w hardeware, manage cpu, manage memory and hard disk...

18) Linux has multikernel architecture.


Class 4 -> Shell Scripting 

1) #!/bin/bash -> to define shebang ...It appears at the very top of a script file and tells the operating system which interpreter should be used to execute the script.


Class 5 -> Docker 

1) Docker is platform for creating and managing containers.
2) Container is something like virtual machine.
3) Virtual machine are something like physical machine.
4) If it fits it ships
5) docker run hello-world -- docker run always create a new Container.
6) docker run -it ubuntu bash -- inside virtual machine

Class 6 -> 

1) Hypervisor allows u to create virtual machine. 
2) Hypervisor has its own operating system.
3) Docker used Hyper-V to run a small Linux VM.
4) BIOS wakes the CPU, RAM, keyboard, storage, etc. BIOS wakes the CPU, RAM, keyboard, storage, etc. Finally, it hands control to the OS (Windows/Linux etc.)
5) Once BIOS knows which storage device to boot from, it looks at the first sector of that storage. That first tiny sector (512 bytes) is called MBR (Master Boot record)
6) MBR contains:
    Bootloader (tiny code that starts the OS loader)
    Partition table (a map of how your drive is divided)
7) docker container inspect container_id
8) docker run -d nginx