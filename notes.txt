Class 1 -> Microservices Architecture

1) 3 axes of scalability ->
 x axis means horizontal scalling, its like load balancers distribute the traffic.
 y axis means vertical scalling, its like functional decomposition into microservices.
 z axis means sharding 

2) Load balancing ->
 Distribute the incoming traffic across instances to maintain avaibility and scalability.
 2 types of balancers -> 
    i) L4 load balancer -> knows only abt ip, port, tcp/udp...jst send the traffic to a
        free server, super fast
    ii) L7 load balancer -> can read the http request content and act accordingly...
        slightly slower.

3) DNS -> A registry of ip adresses for human readable domain name.

4) Service Discovery -> keep track of active service instances for dynamic routing.

5) Sync and Async communication -> f
 sync -> caller wait fr responses...fast but risky, if one goes down, chain reaction.
 async -> caller sends messages and continues...message broker in between: kafka

6) Publish-Subscribe Model & Skew Model (async messaging patterns) ->
    PSM -> Producer sends one message , many consumers can listen.
    Skew -> One message , only one consumer picks it.

7) Event Syncing -> Services publish events to an event bus (Kafka). Other services
    subscribe to events for reactive workflows.

8) API -> Single entry point to all backend microservices.

9) Externalizing Logs -> Never store logs inside containers. They die, logs die. ðŸ’€

10) 12 Factor app -> The bible for cloud native-apps.



Class 2 -> DevOps Introduction

1) What is DevOps -> DevOps basically make a bridge between software development and IT services to deliver application
and services faster and reliable. It is basically set of philosphy, tools etc...

2) SDLC lifecylce -> SDLC is a structured process to build software from idea and deliver and maintanace. Those are planning ,
analysis, design, implementation, testing and integration, maintanance. SDLC mane software development life cycle.

3) Zero Down Time Upgrade -> Deploying a new version of ur application without stopping the existing version of the application.

4) What is there in devops which is not ci-cd -> DevOps practices beyond ci-cd such as IaC, Monitoring & Logging, Version 
 control, security, Collaboration and culture, Containerization etc...ci-cd is only one part of devops.

5) Artifacts -> Final packaged output of a build that can be deployed...ex as JARs, EXE, ZIP, Docker images

6) DevSecOps -> Development + Security + Operation

7) Linting -> Static code checks for style rules, formatting, syntax errors etc...Ex as EsLint

8) Shift-Left Approach -> Testing & security done earlier in the SDLC...instead of testing after coding, shift tests to:
 requirements, design, code-review and build stage...

9) Performance testing tools -> 
 Load testing -> JMeter, LoadRunner, Gatling
 Stress testing -> Locust
 APM Monitoring -> Grafana

10) Software Compliance Analysis (SCA) -> check open source dependencies for vulnarabilities and license issues.

11) Static Analysis Security Testing (SAST) -> Code level security scan without running the program. No runtime behaviour testing. ex as SonarQube.

12) Dynamic Analysis Security Testing (DAST) -> Scan running application and find runtime vulnarabilities.

13) CI/CD -> 
 CI -> Code integration and automatically build and test
 CD -> automatically deploy to environments

14) Continous delivery -> code is ready for release and does require human approval.
    Continous deployment -> code automatically goes to prod, doesnot require human approval.

15) Artifact Repository tools -> 

16) Even if using Docker Images, why Nexus/JFrog?

 * Store other artifacts too (JARs, Helm charts, packages)
 * Versioning & retention policies
 * Faster local access â†’ donâ€™t pull from internet always
 * Secure + governance + scanning
 * Works across multi-cloud environments

Docker Hub â‰  enterprise-grade governance.

17) What is SonarQube?

 A code quality and security scanning tool.
 It performs:
  * SAST
  * Code smells detection
  * Maintainability metrics
  * Bug + Vulnerability reports
  * Coverage tracking

18) High Cyclomatic Complexity ->

 Metric that shows:
 * Too many decision paths in code (if/else)
 * Hard to test & maintain
High value = bad â†’ needs refactor

19) Code Smells (SonarQube)

 Code patterns that may cause future issues:
 * Duplicate code
 * Long methods
 * Dead code
 * Bad naming
                                                                CD
20) System integration Testing (SIT) -> deploy and test(automated) -> Performance Testing -> Security Testing -> DAST -> Production Deploy

21) Mocking and testing -> automated unit test

22) Line coverage , Function coverage and Class coverage

Class 3 -> Linux basics & useful commands

1) Navigation & listing
 - pwd            -> print working directory
 - cd <dir>       -> change directory (cd ~, cd .., cd -)
 - ls             -> list files
   * ls -l        -> long listing (permissions, owner, size, mtime)
   * ls -a        -> include hidden files
   * ls -h        -> human readable sizes
   * ls -t        -> sort by time
   * ls -ltr      -> long listing, reverse by time (oldest first)

2) File & directory operations
 - mkdir <dir>           -> create directory
 - rmdir <dir>           -> remove empty directory
 - rm file               -> remove file
 - rm -r <dir>           -> recursive remove
 - rm -rf <dir>          -> force recursive remove (dangerous)
 - mv src dst            -> move/rename
 - cp src dst            -> copy (cp -r for directories)
 - touch file            -> create empty file / update timestamp

3) Viewing file contents
 - cat file
 - less / more           -> paged viewing
 - head -n 20 file
 - tail -n 50 file
 - tail -f file          -> follow logs
 - echo "text" > file    -> overwrite
 - echo "text" >> file   -> append

4) Permissions model (rwx)
 - Owner / Group / Others each have r (4), w (2), x (1).
 - Numeric examples:
   * 755 -> rwxr-xr-x  (owner rwx, group rx, others rx)
   * 644 -> rw-r--r--  (owner rw, group r, others r)
   * 471 mentioned -> interpreted as special bits + perms:
       - Leading digit (setuid/setgid/sticky): 4=setuid, 2=setgid, 1=sticky
       - 471 -> setuid + owner rwx? (rare); prefer explicit examples.
 - Symbolic examples:
   * chmod u+x file     -> add execute to user
   * chmod g-w file
   * chmod o=r file

5) Special permission bits
 - setuid (4xxx)   -> executable runs with file owner privileges
 - setgid (2xxx)   -> executable/dir inherits group
 - sticky bit (1xxx)-> on directories prevents others from deleting files they don't own (e.g., /tmp has sticky bit)

6) Change ownership & group
 - chown user file
 - chown user:group file
 - chgrp group file

7) ACLs (fine-grained permissions)
 - getfacl file
 - setfacl -m u:alice:rwx file    -> give user alice permissions
 - setfacl -x u:alice file        -> remove ACL entry
 - Useful when owner/group model is insufficient.

8) User management & switching
 - useradd <user> or adduser <user>
 - passwd <user>         -> set password
 - su - <user>           -> switch user (requires password)
 - sudo <cmd>            -> run command as root (requires sudoers)

9) Process management & inspection
 - ps aux               -> all processes (BSD style)
 - ps -ef               -> all processes (UNIX style)
 - ps -efT              -> show threads
 - ps aux | grep sleep  -> find processes (use grep -v grep or pgrep)
 - pgrep <name>         -> get PIDs by name
 - top / htop           -> interactive process viewer
 - kill <pid>, kill -9 <pid>

10) find command (powerful)
 - find /path -name "file.txt"
 - find . -type f        -> files only
 - find . -type d        -> directories only
 - find / -perm 644      -> files with exact permission
 - find . -mtime -7      -> modified within last 7 days
 - find . -size +10M     -> larger than 10MB
 - find . -exec rm {} \; -> run command per result
 - find . -print0 | xargs -0 rm   -> safe with spaces

11) locate
 - locate filename       -> very fast, uses updatedb (database)
 - updatedb              -> rebuild locate database (requires root)

12) Searching & text tools
 - grep "pattern" file
 - grep -R "pattern" dir
 - grep -n "pattern" file -> show line numbers
 - wc -l file            -> count lines
 - sed, awk              -> stream editing / processing

13) File attributes & umask
 - umask                 -> default permission mask for new files (e.g., 022 -> files 644, dirs 755)
 - stat file             -> detailed file metadata

14) Logs & best practices
 - Do not store logs inside containers (ephemeral) â€” redirect to stdout/stderr or external log store.
 - Use full paths in scripts, quote variables, avoid rm -rf mistakes.

15) Useful examples
 - Make a script executable and run:
   * chmod +x script.sh
   * ./script.sh
 - Find and delete *.tmp older than 30 days:
   * find /var/log -type f -name '*.tmp' -mtime +30 -exec rm {} \;
 - Give user alice rwx on file via ACL:
   * setfacl -m u:alice:rwx /data/file

16) Quick tips
 - Prefer sudo for administrative commands instead of logging in as root.
 - Use --dry-run or echo commands before executing destructive operations.
 - Use name-based searches with locate for speed; use find for precise, up-to-date results.

 Summary -> Practice the commands above; focus on permissions (numeric vs symbolic), find/locate, ps variants and process control, and ACLs (setfacl/getfacl).

17) Kernel -> interface b/w hardeware, manage cpu, manage memory and hard disk...

18) Linux has multikernel architecture.


Class 4 -> Shell Scripting 

1) #!/bin/bash -> to define shebang ...It appears at the very top of a script file and tells the operating system which interpreter should be used to execute the script.


Class 5 -> Docker 

1) Docker is platform for creating and managing containers.
2) Container is something like virtual machine.
3) Virtual machine are something like physical machine.
4) If it fits it ships
5) docker run hello-world -- docker run always create a new Container.
6) docker run -it ubuntu bash -- inside virtual machine

Class 6 -> 

1) Hypervisor allows u to create virtual machine. 
2) Hypervisor has its own operating system.
3) Docker used Hyper-V to run a small Linux VM.
4) BIOS wakes the CPU, RAM, keyboard, storage, etc. BIOS wakes the CPU, RAM, keyboard, storage, etc. Finally, it hands control to the OS (Windows/Linux etc.)
5) Once BIOS knows which storage device to boot from, it looks at the first sector of that storage. That first tiny sector (512 bytes) is called MBR (Master Boot record)
6) MBR contains:
    Bootloader (tiny code that starts the OS loader)
    Partition table (a map of how your drive is divided)
7) docker container inspect container_id
8) docker run -d nginx

Class 7 ->

Docker Commands â€” quick reference
 - docker run [OPTIONS] IMAGE [COMMAND] [ARG...] 
   * create and start a container from IMAGE.
   * common options: -d (detached), -it (interactive + tty), --name NAME, --rm (remove after exit), -p HOST:CONTAINER (port mapping), -v HOST:CONTAINER (bind mount/volume), --network NAME.
   Example: docker run -d --name web -p 8080:80 nginx

 - docker build -t myimage:tag PATH
   * builds image from a Dockerfile in PATH. Use --no-cache, --target for multi-stage builds.
   Example: docker build -t app:latest .

 - docker pull IMAGE
   * download image from registry (Docker Hub, private registry).

 - docker push IMAGE
   * upload image to a registry.

 - docker images
   * list local images.

 - docker ps / docker ps -a
   * list running / all containers.

 - docker logs [OPTIONS] CONTAINER
   * fetch container stdout/stderr (useful for debugging).

 - docker exec -it CONTAINER CMD
   * run a command inside a running container (e.g., bash).

 - docker inspect OBJECT
   * show low-level JSON details about images/containers/networks.

 - docker rm CONTAINER / docker rmi IMAGE
   * remove container / image.

 - docker save IMAGE > image.tar / docker load < image.tar
   * export/import images as tarball.

 - docker volume create/list/rm
   * manage named volumes.

 - docker network create/list/rm
   * manage docker networks.

Dockerfile basics (very short)
 - FROM baseimage
 - RUN commands (creates a layer)
 - COPY / ADD files
 - ENV, WORKDIR, EXPOSE, USER
 - CMD / ENTRYPOINT define runtime process
 - Each Dockerfile instruction produces a layer; ordering matters for cache.

Image internals â€” how images are built & stored
 - Images are immutable sets of filesystem layers (read-only). Each Dockerfile instruction that changes filesystem typically creates a new layer.
 - Layers are content-addressable blobs stored by the daemon (overlay2 is the common storage driver).
 - Image metadata: manifest (list of layers), config (env, cmd, exposed ports), and content-addressable layer blobs.
 - Build process:
   1) Dockerfile parsed by build engine (buildkit/dockerd).
   2) Each instruction executed in an ephemeral container; filesystem diffs become layers.
   3) Layers are stored and referenced by digest; final image manifest points to layers and config.
 - Registries store image manifests and layer blobs; docker pull/fetch downloads blobs referenced by manifest.

Container internals â€” how a container is created & run
 - Container = runtime instance of an image + a writable layer (copy-on-write).
 - Key components:
   * Docker daemon (dockerd) â€” manages images, containers, networks, volumes.
   * containerd â€” daemon that handles container lifecycle (images, snapshots, containers).
   * runc (OCI runtime) â€” creates namespaces and starts the container process.
 - Creation steps (simplified):
   1) Client asks dockerd to create container from image.
   2) daemon creates a writable snapshot on top of image read-only layers (overlay with copy-on-write).
   3) daemon prepares container config (namespace, cgroups, mounts, env, user, capabilities).
   4) containerd/runc create the container: set up Linux namespaces (pid, net, mnt, ipc, uts, user) and apply cgroups for resource limits.
   5) runc forks and execs the container's init process (PID 1 inside namespace). Docker attaches stdio and networking according to the config.
 - Isolation mechanisms:
   * Namespaces isolate filesystem, process tree, network, UTS (hostname), IPC, user.
   * cgroups limit CPU, memory, IO resources.
   * Seccomp, AppArmor / SELinux provide syscall and MAC-level controls.
 - Filesystem behavior:
   * Image layers are read-only. Writable layer (upper) stores container changes; when files are modified, copy-on-write duplicates them into the writable layer.
   * Volumes and bind mounts bypass the image layers and persist data outside container's writable layer.

Common runtime pieces and flow
 - docker client -> dockerd -> containerd -> runc -> kernel
 - Logs typically go to stdout/stderr of PID 1 and are collected by the daemon (docker logs / logging drivers).
 - Networking: default bridge network + docker-proxy or userland routing; modern setups use libnetwork and bridge/overlay drivers.

Concise troubleshooting hints
 - If container won't start: docker logs, docker inspect, check ENTRYPOINT/CMD, check permissions for mounted volumes.
 - To see filesystem layers: docker history IMAGE
 - To see runtime namespaces and processes: lsns, ps auxf, inspect with docker inspect and look for Mounts/Config/HostConfig.

Summary
 - Docker CLI offers commands to build, run, inspect, and manage images/containers.
 - Images are layered, immutable artifacts built from Dockerfiles and stored as blobs+manifests.
 - Containers are isolated runtime instances created by combining image layers with a writable layer, using kernel namespaces and cgroups, orchestrated by dockerd/containerd and executed via an OCI runtime (runc).